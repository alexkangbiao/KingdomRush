#include "Mecha.h"#include "GameManager.h"#include "Bomb.h"#include "Shit.h"bool Mecha::init() {    if (!BaseSoldier::initWithSoldierType(SOLDIER_TYPE_MECHA, 1)) {		return false;	}        _canShit       = true;    _farestMonster = nullptr;    _monsterCount  = 0;        this->addShitShooterSprite();	this->schedule(schedule_selector(Mecha::bombMonster), this->getAttackPeriod());    	return true;}#pragma mark - for shit functionvoid Mecha::addShitShooterSprite() {    _shitShooterSprite = Sprite::createWithSpriteFrameName("Mecha_Shitting_0001.png");    this->addChild(_shitShooterSprite);}void Mecha::addShitBullut(){    SoundManager::playMechShit();    auto shit = Shit::create();    shit->setPosition(Point(this->getPosition().x,                            this->getPosition().y - baseSprite->getContentSize().height / 2));    this->getParent()->addChild(shit);    shit->shoot();    _canShit = false;    this->scheduleOnce(schedule_selector(Mecha::setCanShit), 10.0f);}void Mecha::setCanShit(float dt) {    _canShit = true;}void Mecha::shitting(){    _shitShooterSprite->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("Mecha_shitting")));}#pragma mark - for init functionvoid Mecha::setAnimationAndOthers() {    _soldierWaitingSpriteFrame = SpriteFrameCache::getInstance()->getSpriteFrameByName("Mecha_0001.png");}#pragma mark - for missile functionvoid Mecha::shootMissiles(){    log("Missile Vector number is : %ld", _missileVector.size());        Missile *missile = nullptr;    //循环使用已经生成的子弹，否则就转到生成新子弹    for (int i = 0; i < _missileVector.size(); i++) {        if (! _missileVector.at(i)->getParent()) {            _missileVector.at(i)->restoreBullet();            missile = _missileVector.at(i);            break;        }    }        if (!missile) {        missile = Missile::create();        _missileVector.pushBack(missile);    }//    auto missile = Missile::create();	missile->setBulletPosition(this->getSoldierPosition());	this->getParent()->addChild(missile);	missile->setVisible(false);    //    log("missile Position x: %f y: %f )",//        missile->getPosition().x, missile->getPosition().y);//    log("missile->getParent()->getPosition() x: %f y: %f )",//        missile->getParent()->getPosition().x, missile->getParent()->getPosition().y);//    log("missile->getBulletPosition() x: %f y: %f )",//        missile->getBulletPosition().x, missile->getBulletPosition().y);    	baseSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("Mecha_shoot")),                                           CallFuncN::create(CC_CALLBACK_0(Missile::setVisible, missile, true)),                                           CallFuncN::create(CC_CALLBACK_0(Missile::shoot, missile, _farestMonster, this->getPosition())),                                           NULL));}#pragma mark - for attack monster functionvoid Mecha::bombMonster(float dt){	this->checkNearestMonster();	if (_canShit && _monsterCount >= 3) {		baseSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("Mecha_shit")),                                               CallFuncN::create(CC_CALLBACK_0(Mecha::shitting, this)),                                               CallFuncN::create(CC_CALLBACK_0(Mecha::addShitBullut, this)),                                               NULL));	} else {		if ( _nearestMonster != NULL && _nearestMonster->getCurrentHP() > 0 ) {			Point shootVector = _nearestMonster->getMonsterPosition() - this->getParent()->getPosition();			auto currentBullet = this->getMechaBullet();			if (_nearestMonster->getMonsterPosition().x - (this->getParent()->getPosition() + this->getPosition()).x > 0) {				baseSprite->setFlippedX(false);				_shitShooterSprite->setFlippedX(false);				currentBullet->setPosition(Point(currentBullet->getPosition().x - 30,                                                 currentBullet->getPosition().y + 30));			} else {				baseSprite->setFlippedX(true);				_shitShooterSprite->setFlippedX(true);				currentBullet->setPosition(Point(currentBullet->getPosition().x + 30,                                                 currentBullet->getPosition().y + 30));			}			Point highPoint = Point(shootVector.x,                                    shootVector.y + 200);			ccBezierConfig bezier;			bezier.controlPoint_1 = Point(currentBullet->getPosition().x,                                          currentBullet->getPosition().y+200);			bezier.controlPoint_2 = Point(shootVector.x,                                          shootVector.y + 200);;			bezier.endPosition = shootVector;                        float duringTime = this->caculateSpendTime(_nearestMonster->getMonsterPosition());            			auto action = Spawn::create(BezierTo::create(duringTime, bezier),                                        RotateTo::create(duringTime, 540.0f),                                        nullptr);			currentBullet->setBulletAction(action);			currentBullet->shoot();            			baseSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("Mecha_attack")),                                                   nullptr));			currentBullet = nullptr;		} else {			this->checkFarestMonster();			if (_farestMonster != nullptr && _farestMonster->getCurrentHP() > 0) {				Point shootVector = _farestMonster->getMonsterPosition() - (this->getParent()->getPosition() + this->getPosition());				if (shootVector.x > 0) {					baseSprite->setFlippedX(false);					_shitShooterSprite->setFlippedX(false);				} else {					baseSprite->setFlippedX(true);					_shitShooterSprite->setFlippedX(true);				}				this->shootMissiles();			} else {				baseSprite->setFlippedX(!(baseSprite->isFlippedX()));			}		}	}}#pragma mark - for private functionBomb* Mecha::getMechaBullet(){    log("arrow vector number is : %ld", _bombVector.size());        //循环使用已经生成的子弹，否则就转到生成新子弹    for (int i = 0; i < _bombVector.size(); i++) {        if (!_bombVector.at(i)->getParent()) {            _bombVector.at(i)->restoreBullet();            this->getParent()->addChild(_bombVector.at(i));            return _bombVector.at(i);        }    }    	auto bullet = Bomb::createBombWithLevel(4);	bullet->setPosition(this->getPosition());	this->getParent()->addChild(bullet);        _bombVector.pushBack(bullet);        return bullet;}void Mecha::runToLocation(Point toPoint){	this->stopAllActions();	baseSprite->stopAllActions();	this->unschedule(schedule_selector(Mecha::bombMonster));    	if ((toPoint.x - this->getPositionX()) > 0) {		baseSprite->setFlippedX(false);//右边	} else {		baseSprite->setFlippedX(true);	}    	baseSprite->runAction(RepeatForever::create(Animate::create(AnimationCache::getInstance()->getAnimation("Mecha_walk"))));	this->runAction(Sequence::create(MoveTo::create(this->caculateSpendTime(toPoint), toPoint),                                     CallFuncN::create(CC_CALLBACK_0(Sprite::stopAllActions,baseSprite)),                                     NULL));	SoundManager::playMechWalk();	this->schedule(schedule_selector(Mecha::bombMonster), this->getAttackPeriod(), -1, this->caculateSpendTime(toPoint));}//void Mecha::checkNearestMonster()//{//	_monsterCount = 0;//	auto instance = GameManager::getInstance();//    auto monsterVector = instance->monsterVector;//    //	auto currMinDistant = 200;//    //	BaseMonster *monsterTemp = nullptr;//	for(int i = 0; i < monsterVector.size(); i++)//	{//		auto monster = monsterVector.at(i);//		double distance = (this->getParent()->getPosition()+this->getPosition()).getDistance(monster->getMonsterPosition());////		if (distance < currMinDistant && monster->getEnableAttackBySoldier()) {//			currMinDistant = distance;//            monsterTemp = monster;//			_monsterCount ++;//		}//	}//    nearestMonster = monsterTemp;//}//void Mecha::checkFarestMonster() {//    auto monsterVector = GameManager::getInstance()->monsterVector;//    //	auto currentMinDistant = 200;//    //	BaseMonster *monsterTemp = NULL;//	for(int i = 0; i < monsterVector.size(); i++)//	{//		auto monster = monsterVector.at(i);//		double distance = this->getParent()->getPosition().getDistance(monster->getMonsterPosition());////		if (distance > currentMinDistant && monster->getEnableAttackByTower()) {//			currentMinDistant = distance;//            monsterTemp = monster;//			break;//		}//	}//    //    _farestMonster = monsterTemp;//}