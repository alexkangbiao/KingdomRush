#include "Assassin.h"#include "GameManager.h"Assassin* Assassin::createAssassin(Point toPoint){    auto assassin = new Assassin();    if (assassin && assassin->init()) {        assassin->setLocation(toPoint);        assassin->runToLocation(toPoint);                assassin->autorelease();        return assassin;    }    CC_SAFE_DELETE(assassin);    return NULL;}bool Assassin::init() {    if (!BaseSoldier::initWithSoldierType(SOLDIER_TYPE_ASSASSIN, 1)) {        return false;    }    return true;}//void Assassin::startGuardState()//{//    if (nearestMonster != NULL) {//        this->scheduleUpdate();//        this->schedule(schedule_selector(Assassin::attackMonster), this->getAttackPeriod(), -1, 0);//    } else {//        this->runToLocation(getLocation());//    }//}#pragma mark - for some private functionvoid Assassin::setAnimationAndOthers() {    _animationDeath  = AnimationCache::getInstance()->getAnimation("Assassin_dead");    _animationAttack = AnimationCache::getInstance()->getAnimation("Assassin_attack");    _animationRun    = AnimationCache::getInstance()->getAnimation("Assassin_run");    _animationSkill1  = AnimationCache::getInstance()->getAnimation("Assassin_skill1");    _animationSkill2  = AnimationCache::getInstance()->getAnimation("Assassin_skill2");    _soldierWaitingSpriteFrame = SpriteFrameCache::getInstance()->getSpriteFrameByName("Soldier_Assassin_0001.png");}void Assassin::setSoldierAttackState(float & monsterCurrentHP) {    _attackCount ++;    switch (_attackCount % 3) {        case(0):            this->setState(SoldierStateAttack);            monsterCurrentHP =  monsterCurrentHP - this->getForce() + _nearestMonster->getArmor();            break;        case(1):            this->setState(SoldierStateSkill2);            monsterCurrentHP =  monsterCurrentHP - this->getForce() - 10 + _nearestMonster->getArmor();            break;        case(2):            this->setState(SoldierStateSkill1);            monsterCurrentHP =  monsterCurrentHP - this->getForce() - 20 + _nearestMonster->getArmor();            break;    }}//void Assassin::attackMonster(float dt)//{//    if (nearestMonster != NULL && nearestMonster->getCurrentHP() > 0) {//        auto monsterCurrentHP = nearestMonster->getCurrentHP();//        auto soldierCurrentHP = this->getCurrentHP();//        _attackCount ++;//        switch (_attackCount % 3) {//            case(0)://                this->setState(SoldierStateAttack);//                monsterCurrentHP =  monsterCurrentHP - this->getForce() + nearestMonster->getArmor();//                break;//            case(1)://                this->setState(SoldierStateSkill2);//                monsterCurrentHP =  monsterCurrentHP - this->getForce() - 10 + nearestMonster->getArmor();//                break;//            case(2)://                this->setState(SoldierStateSkill1);//                monsterCurrentHP =  monsterCurrentHP - this->getForce() - 20 + nearestMonster->getArmor();//                break;//        }//        //        if (nearestMonster->getMonsterState() != MonsterStateFrozen)//            soldierCurrentHP = soldierCurrentHP - nearestMonster->getForce() + this->getArmor();//        //        if (monsterCurrentHP <= 0) monsterCurrentHP = 0;//        //        if (soldierCurrentHP <= 0) soldierCurrentHP = 0;//        //        nearestMonster->setCurrentHP( monsterCurrentHP );//        nearestMonster->getHpBar()->setPercentage((monsterCurrentHP / nearestMonster->getMaxHp()) * 100);//        this->setCurrentHP(soldierCurrentHP);//        this->getHpBar()->setPercentage((soldierCurrentHP / this->getMaxHp()) * 100);//        //        if (monsterCurrentHP == 0) {//            this->unschedule(schedule_selector(Assassin::attackMonster));//            nearestMonster->death();//            if (this->getCurrentHP() > 0) this->runToLocation(_location);//        }//        //        if (soldierCurrentHP == 0) {//            _lastState = SoldierStateDeath;//            this->setState(SoldierStateDeath);//            this->unscheduleAllCallbacks();//            this->stopAllActions();//            //            baseSprite->stopAllActions();//            //            if (nearestMonster != NULL && nearestMonster->getCurrentHP() > 0) {//                nearestMonster->restartWalking();//                nearestMonster->setIsAttacking(false);//            }//            //            baseSprite->runAction(Sequence::create(CallFuncN::create(CC_CALLBACK_0(Assassin::setState, this, SoldierStateDeath)),//                                                   Animate::create(_animationDeath),//                                                   FadeOut::create(1.0f),//                                                   NULL));//        }//    } else {//        this->unschedule(schedule_selector(Assassin::attackMonster));//        if (this->getCurrentHP() > 0) this->runToLocation(_location);//    }//    //}