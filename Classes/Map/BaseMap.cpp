#include "BaseMap.h"#include "RespirationSprite.h"#include "WaveFlag.h"#include "Victory.h"#include "Failure.h"#include "SoundManager.h"#include "Boss_Efreeti.h"#include "Boss_Canibal.h"#include "Utility.h"#include "BeginStory.h"#include "AnimationManager.h"#include "Monster.h"#include "SpriteCacheManager.h"#include "GameManager.h"USING_NS_CC;#define PATH_X_PARAMETER 1.15#define PATH_Y_PARAMETER 1.20 + 50;bool BaseMap::init(int level, int difficult) {    if ( ! Layer::init() ) {        return false;    }    _level = level;    _difficulty = difficult;        _isStart = false;    _isEnd = false;    _time = 0;    _currentWaveNumber = -1;        _musicEffect   = LevelMusicEffectDesert;    _hasStartStory = false;        GameManager::getInstance()->CURRENT_LEVEL = _level;    //载入每一关配置文件，这里有这一关的类型等信息    this->loadLevelConfigData();    //载入每一关需要的怪物渲染图片文件    this->loadLevelMonsterSpriteCacheFile();        //载入每一关怪物的数据    this->loadLevelMonsterDataFromFile();    //载入每一关行进路线数组    this->loadPathsVectorFromFile();    //载入每一关起始点的位置信息    this->loadWaveStartPointsFromFile();    //载入每一关需要载入的图片文件    this->loadLevelSpriteFrameFile();        //添加背景文件    this->addBackgroundMapImage();    //添加怪物动画缓存    this->loadMonsterAnimationCache();    //添加装饰图片    this->addOrnament();    //添加炮塔配置位置    this->addTerrains();    //添加触摸层    this->initTouchLayer();    this->setMapPosition();    this->playLevelMusicEffect();        return true;}#pragma mark - for init functionvoid BaseMap::initTouchLayer() {    //设置防御塔升级菜单层    mTouchLayer = TouchLayer::create();    mTouchLayer->setContentSize(mapBackgroundSprite->getContentSize());    mTouchLayer->setAnchorPoint(Vec2::ZERO);    mTouchLayer->setPosition(Vec2::ZERO);    this->addChild(mTouchLayer, BaseMapDrawingOrderTouchLayer);}TouchLayer* BaseMap::getTouchLayer() {    return this->mTouchLayer;}//void BaseMap::bindTouchLayer(TouchLayer* mTouchLayer) {//    this->mTouchLayer = mTouchLayer;//}#pragma mark - for virtual functionvoid BaseMap::onEnterTransitionDidFinish() {    if (_hasStartStory) {        this->startStory();    } else {        this->startGame();    }}void BaseMap::onExitTransitionDidStart() {    GameManager::getInstance()->eraseAllMonsterVector();    GameManager::getInstance()->eraseAllMonsterInusedVector();        this->unscheduleAllCallbacks();}void BaseMap::onExit() {    Layer::onExit();        //清除所有所有的数据结构    GameManager::getInstance()->eraseAllMonsterVector();    GameManager::getInstance()->eraseAllMonsterInusedVector();        this->releaseMonsterAnimationCache();    this->releaseLevelMonsterSpriteCacheFile();    this->removeLevelSpriteFrameFile();}void BaseMap::update(float dt) {    this->updateGoldAndLifeNumber();    //判断是否胜利    if (_isStart && _isEnd && GameManager::getInstance()->monsterVector.size() == 0) {        _isStart = false;        _isEnd   = false;        this->victory();    }}#pragma mark - for start functionvoid BaseMap::startGame() {    if (_hasStartStory) {        _colorLayer->removeFromParent();    }        GameManager::getInstance()->CURRENT_MONEY = _startGoldNumber;    GameManager::getInstance()->CURRENT_LIFE  = _maxLifeNumber;    playerStateMenu->playerStateLabel->setGoldLabel(_startGoldNumber);    playerStateMenu->playerStateLabel->setLifeLabel(_maxLifeNumber);    playerStateMenu->playerStateLabel->setWaveLabel(0, _maxWaveNumber);    //    playerState->startProgressTimers();        this->scheduleUpdate();    this->schedule(schedule_selector(BaseMap::addWaves), 0.5f);}void BaseMap::startStory() {    _colorLayer = LayerColor::create(Color4B::BLACK, 1200, 1000);    this->addChild(_colorLayer, BaseMapDrawingOrderColorLayer);        auto story = BeginStory::create();    story->setGameScene(this);    playerStateMenu->addChild(story, PlayerStateMenuDrawingOrderStory);}#pragma mark - for add functionvoid BaseMap::addBackgroundMapImage() {    mapBackgroundSprite = Sprite::createWithSpriteFrameName(Utility::string_format("Stage_%d.png", _level + 1));    mapBackgroundSprite->setAnchorPoint(Vec2::ZERO);    mapBackgroundSprite->setPosition(Vec2::ZERO);    this->addChild(mapBackgroundSprite, BaseMapDrawingOrderBackground);}#pragma mark - for victory functionvoid BaseMap::victory() {    //停止计时器//    auto instance = GameManager::getInstance();//    auto dataInstance = UserDefault::getInstance();    this->unscheduleUpdate();    this->unschedule(schedule_selector(BaseMap::addWaves));    this->unschedule(schedule_selector(BaseMap::addMonsters));        //若此关卡得星数为0，则表示第一次完成    if(UserDefault::getInstance()->getIntegerForKey(                   StringUtils::format(GameManager::getInstance()->LEVEL_SLOTX_STAR_NUMBER, getLevel()).c_str(), 0) == 0)    {        UserDefault::getInstance()->setIntegerForKey(GameManager::getInstance()->LEVEL_SLOTX_NEW_OPEN, getLevel() + 1);    }    //判断完成等级给星    int getStarNumber = 0;    switch (_difficulty) {        case(0):            if ( GameManager::getInstance()->CURRENT_LIFE >= 18) {                getStarNumber = 3;            } else if(GameManager::getInstance()->CURRENT_LIFE > 10){                getStarNumber = 2;            } else {                getStarNumber = 1;            }            break;        case(1):            getStarNumber = 4;            break;        case(2):            getStarNumber = 5;            break;    }    //若此次得到的星星大于之前记录，更新    int oldStarNumber = UserDefault::getInstance()->getIntegerForKey(                                StringUtils::format(GameManager::getInstance()->LEVEL_SLOTX_STAR_NUMBER,getLevel()).c_str(), 0);    if (getStarNumber > oldStarNumber) {        //之前星星个数        int starCount = UserDefault::getInstance()->getIntegerForKey(GameManager::getInstance()->SLOT_X_STAR_NUMBER_SUM);        //加上得到的星星SLOT_X_STAR_NUMBER_SUM        UserDefault::getInstance()->setIntegerForKey(GameManager::getInstance()->SLOT_X_STAR_NUMBER_SUM, starCount + getStarNumber - oldStarNumber);        //更新本关星星        UserDefault::getInstance()->setIntegerForKey(                    StringUtils::format(GameManager::getInstance()->LEVEL_SLOTX_STAR_NUMBER, getLevel()).c_str(), getStarNumber);        //更新剩余星星个数        UserDefault::getInstance()->setIntegerForKey(                            GameManager::getInstance()->SLOT_X_STAR_LEFT,                            UserDefault::getInstance()->getIntegerForKey(GameManager::getInstance()->SLOT_X_STAR_LEFT)                                                     + getStarNumber - oldStarNumber);    }    //更新得到的钻石钻石    int gem = getStarNumber * 10 * (_level + 1) / 2;    int oldGem = UserDefault::getInstance()->getIntegerForKey(GameManager::getInstance()->SLOTX_DIAMOND_NUMBER);    UserDefault::getInstance()->setIntegerForKey(GameManager::getInstance()->SLOTX_DIAMOND_NUMBER, gem + oldGem);        //根据难度，星，钻，显示胜利画面    auto victory = Victory::createVictory(getStarNumber, gem);    mTouchLayer->removeAllChildren();    victory->setLevel(this->getLevel());    victory->setDifficult(_difficulty);    playerStateMenu->addChild(victory, PlayerStateMenuDrawingOrderNoticeInterface);}#pragma mark - for load data functionvoid BaseMap::loadWaveStartPointsFromFile() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_wave_startpoint.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        std::vector<Point> points;    //parse the terrains data    auto arrayStartPoints = valueMap.at("startpoints").asValueVector();    for (int i = 0; i< arrayStartPoints.size(); i++) {        auto valueMap = (arrayStartPoints[i]).asValueMap();        //        int id = atoi((valueMap["id"]).asString().c_str());        auto x  = atof((valueMap["x"]).asString().c_str());        auto y  = atof((valueMap["y"]).asString().c_str());        x = x / Director::getInstance()->getContentScaleFactor();        y = y / Director::getInstance()->getContentScaleFactor();                points.push_back(Point(x, y));    }    this->addWaveProgressBars(points);    for (int i = 0; i < _waveFlags.size(); i++) {        _waveFlags.at(i)->restartWaveFlag();    }    }void BaseMap::loadLevelMonsterDataFromFile() {    //加载初始血量金钱等    std::string fileName = "xml/level" + std::to_string(_level) + "_" + std::to_string(_difficulty) + "_monsters.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        //parse the data    auto arrayDatas = valueMap.at("data").asValueVector();    for (int i = 0; i< arrayDatas.size(); i++) {        auto dataMap = (arrayDatas[i]).asValueMap();        _startGoldNumber = atoi((dataMap["gold"]).asString().c_str());        _maxLifeNumber   = atoi((dataMap["life"]).asString().c_str());        _maxWaveNumber   = atoi((dataMap["wave"]).asString().c_str());    }        //parse the monster data    auto arrayMonsters = valueMap.at("monsters").asValueVector();    for (int i = 0; i < arrayMonsters.size(); i++) {        auto items = (arrayMonsters[i]).asValueVector();        std::vector<Vector<GroupMonster*>> waveSubVector;                for (int j = 0; j < items.size(); j++) {            auto subItems = (items[j]).asValueVector();            Vector<GroupMonster *> groupMonsterVector;                        for (int k = 0; k < subItems.size(); k++) {                auto valueMap = (subItems[k]).asValueMap();                GroupMonster * groupMonster =                GroupMonster::createWithData(atoi((valueMap["type"]).asString().c_str()),                                             atoi((valueMap["road"]).asString().c_str()),                                             atoi((valueMap["path"]).asString().c_str()));                                groupMonsterVector.pushBack(groupMonster);                                //载入本关所需怪物的类型，用户怪物动画缓冲缓存的加载和释放                if (atoi((valueMap["type"]).asString().c_str()) >= 0) {                    _monsterTypeSet.insert(atoi((valueMap["type"]).asString().c_str()));                }//                log("type = %d", atoi((valueMap["type"]).asString().c_str()));            }            waveSubVector.push_back(groupMonsterVector);        }        _waveVector.push_back(waveSubVector);    }}void BaseMap::loadPathsVectorFromFile() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_paths.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        auto arrayPaths = valueMap.at("paths").asValueVector();        for (int i = 0; i< arrayPaths.size(); i++) {        auto items = (arrayPaths[i]).asValueVector();        std::vector<std::vector<Point>> pointItemVector;        for (int j = 0; j < items.size(); j++) {            auto subItems = (items[j]).asValueVector();            std::vector<Point> pointVector;                        for (int k = 0; k < subItems.size(); k++) {                auto keyValue = (subItems[k]).asValueMap();                auto x = atof((keyValue["x"]).asString().c_str());                auto y = atof((keyValue["y"]).asString().c_str());                //                x = x / Director::getInstance()->getContentScaleFactor();//                y = y / Director::getInstance()->getContentScaleFactor();                                x = x * 1.15;                y = y * 1.20 + 50;                                Point point = Point(x, y);                                pointVector.push_back(point);            }            pointItemVector.push_back(pointVector);        }        _gamePaths.push_back(pointItemVector);    }}//添加配置信息void BaseMap::loadLevelConfigData() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_config.plist";    if (FileUtils::getInstance()->isFileExist(fileName)) {        auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);                //执行Level Music Effect        _musicEffect   = atoi((valueMap["musiceffect"]).asString().c_str());                _hasStartStory = atoi((valueMap["startstory"]).asString().c_str()) == 1 ? true : false;    }}#pragma mark - WaveProgressBarvoid BaseMap::showWaveProgressBars(float dt) {    for (int i = 0; i < _waveFlags.size(); i++) {        _waveFlags.at(i)->restartWaveFlag();    }}void BaseMap::addWaveProgressBars(std::vector<Point> waveFlagLocations) {    for (unsigned int i = 0; i < waveFlagLocations.size(); i++){        auto waveFlag = WaveFlag::create();        waveFlag->setPosition(waveFlagLocations.at(i));        this->addChild(waveFlag, BaseMapDrawingOrderWaveFlag);        auto waveflagListener = EventListenerTouchOneByOne::create();        waveflagListener->onTouchBegan = CC_CALLBACK_2(BaseMap::onWaveProgressBarTouchBegan, this);        waveflagListener->setSwallowTouches(true);        _eventDispatcher->addEventListenerWithSceneGraphPriority(waveflagListener, waveFlag);        _waveFlags.pushBack(waveFlag);    }}bool BaseMap::onWaveProgressBarTouchBegan(Touch* touch, Event* event) {    auto target = static_cast<WaveFlag*>(event->getCurrentTarget());        Point locationInNode = target->convertTouchToNodeSpace(touch);        Size size = target->getWaveFlagContentSize();    Rect rect = Rect(0 - size.width / 2, 0 - size.height / 2, size.width, size.height);    if (rect.containsPoint(locationInNode) && target->getIsShown())    {        //这里判断是否是第二次点击，第一次点击为选择，第二次点击就执行下面的程序        if (target->_selectedSprite->isVisible()) {            int money = 100 - target->getWavePercentage();            GameManager::getInstance()->CURRENT_MONEY += money;            mTouchLayer->addMoneyLabel(target->getWaveFlagPosition(), money);                        for (int i = 0; i < _waveFlags.size(); i++) {                _waveFlags.at(i)->stopRespiration();            }        }        for (int i = 0; i < _waveFlags.size(); i++) {            _waveFlags.at(i)->setSelected();        }        return true;    }    return false;}void BaseMap::setMapPosition() {    Size visiableSize = Director::getInstance()->getVisibleSize();        Point location = Point();    auto mapSize = mapBackgroundSprite->getBoundingBox().size;        location.x = visiableSize.width  / 2 - mapSize.width / 2;    location.y = visiableSize.height / 2 - mapSize.height / 2;    location.x = MIN(location.x, 0);    location.x = MAX(location.x, - mapSize.width + visiableSize.width);    location.y = MIN(location.y, 0);    location.y = MAX(location.y, - mapSize.height + visiableSize.height);    this->setPosition(location);}void BaseMap::updateGoldAndLifeNumber() {    if (GameManager::getInstance()->CURRENT_LIFE > 0) {        playerStateMenu->playerStateLabel->setGoldLabel(GameManager::getInstance()->CURRENT_MONEY);        playerStateMenu->playerStateLabel->setLifeLabel(GameManager::getInstance()->CURRENT_LIFE);    } else if (_isStart) {        _isStart = false;        playerStateMenu->playerStateLabel->setLifeLabel(0);        this->unscheduleAllCallbacks();        for (int i = 0; i < _waveFlags.size(); i++) {            _waveFlags.at(i)->stopRespiration();        }        auto failure = Failure::create();        mTouchLayer->removeAllChildren();        failure->setLevel(_level);        failure->setDifficulty(_difficulty);                playerStateMenu->addChild(failure, PlayerStateMenuDrawingOrderNoticeInterface);    }}#pragma mark - add function/* Ornament的类型： 0：只是针对单点装饰 1：对于可变多点装饰 2：针对不变的图片文件但是是多点装饰 3：带有动画的单点装饰 */void BaseMap::addOrnament() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_ornaments.plist";    if (FileUtils::getInstance()->isFileExist(fileName)) {        auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);                //parse the ornaments data        auto arrayOrnaments = valueMap.at("ornaments").asValueVector();        for (int i = 0; i< arrayOrnaments.size(); i++) {            auto valueMap = (arrayOrnaments[i]).asValueMap();//            int id = atoi((valueMap["id"]).asString().c_str());            int type  = atoi((valueMap["type"]).asString().c_str());                        //只是针对单点装饰            if (type == 0) {                auto point = Point(atof((valueMap["x"]).asString().c_str()),                                   atof((valueMap["y"]).asString().c_str()));                auto ornament = Sprite::createWithSpriteFrameName((valueMap["imagename"]).asString().c_str());                ornament->setPosition(point);                this->addChild(ornament, BaseMapDrawingOrderOrnament);            }                        //对于可变多点装饰            if (type == 1) {                auto point = Point(atof((valueMap["x"]).asString().c_str()),                                   atof((valueMap["y"]).asString().c_str()));                int from  = atoi((valueMap["from"]).asString().c_str());                int to    = atoi((valueMap["to"]).asString().c_str());                auto pointVector = valueMap.at("points").asValueVector();                int j = 0;                for (int i = from; i <= to; i++) {                    std::string imageName = StringUtils::format((valueMap["imagename"]).asString().c_str(), i);                    auto ornament = Sprite::createWithSpriteFrameName(imageName);                    auto pointMap = pointVector.at(j).asValueMap();                    auto point = Point(atof((pointMap["x"]).asString().c_str()),                                       atof((pointMap["y"]).asString().c_str()));                    ornament->setPosition(point);                    this->addChild(ornament, BaseMapDrawingOrderOrnament);                    j++;                }            }                        //针对不变的图片文件但是是多点装饰            if (type == 2) {                std::string imageName = (valueMap["imagename"]).asString().c_str();                auto pointVector = valueMap.at("points").asValueVector();                for (int i = 0; i < pointVector.size(); i++) {                    auto ornament = Sprite::createWithSpriteFrameName(imageName);                    auto pointMap = pointVector.at(i).asValueMap();                    auto point = Point(atof((valueMap["x"]).asString().c_str()),                                       atof((valueMap["y"]).asString().c_str()));                    ornament->setPosition(point);                    this->addChild(ornament, BaseMapDrawingOrderOrnament);                }            }                        //带有动画的单点装饰            if (type == 3) {                auto point = Point(atof((valueMap["x"]).asString().c_str()),                                   atof((valueMap["y"]).asString().c_str()));                auto ornament = Sprite::createWithSpriteFrameName((valueMap["imagename"]).asString().c_str());                ornament->setPosition(point);                this->addChild(ornament, BaseMapDrawingOrderOrnament);                                auto arrayAnimation = valueMap.at("animation").asValueVector();                for (int j = 0; j < arrayAnimation.size(); j++) {                    auto animationMap = (arrayAnimation[j]).asValueMap();                    auto waveAnimation = WaveAnimation::create(ornament, animationMap);                    _waveAnimationMap.insert(waveAnimation->getWaveNumber(), waveAnimation);                }            }        }    }}void BaseMap::addTerrains() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_terrains.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        //parse the terrains data    auto arrayTerrains = valueMap.at("terrains").asValueVector();    for (int i = 0; i < arrayTerrains.size(); i++) {        auto valueMap = (arrayTerrains[i]).asValueMap();        int id = atoi((valueMap["id"]).asString().c_str());        int type  = atoi((valueMap["type"]).asString().c_str());        auto x  = atof((valueMap["x"]).asString().c_str());        auto y  = atof((valueMap["y"]).asString().c_str());                x = x / Director::getInstance()->getContentScaleFactor();        y = y / Director::getInstance()->getContentScaleFactor();                auto terrain = Terrain::createTerrain(type);        terrain->setPosition(Point(x, y));        terrain->setTag(id);        this->addChild(terrain, BaseMapDrawingOrderTerrain);    }}void BaseMap::bindPlayerStateMenu(PlayerStateMenu* playerStateMenu) {    this->playerStateMenu = playerStateMenu;    this->playerStateMenu->mTouchLayer = mTouchLayer;}#pragma mark - for Monster Wave functionvoid BaseMap::addWaves(float dt) {    bool newWave = false;    for (int i = 0; i < _waveFlags.size(); i++) {        if (_waveFlags.at(i)->getWavePercentage() == 100.0f) {            newWave = true;            break;        }    }    if (newWave && _currentWaveNumber < _maxWaveNumber) {        _isStart = true;        SoundManager::playIncomingWave();        _currentWaveNumber++;        for (int i = 0; i < _waveFlags.size(); i++) {            _waveFlags.at(i)->setWavePercentage(0.0f);        }        playerStateMenu->playerStateLabel->setWaveLabel(_currentWaveNumber + 1, _maxWaveNumber);        this->waveEvent();    }}void BaseMap::loadLevelMonsterSpriteCacheFile() {    switch (_musicEffect) {        case LevelMusicEffectDesert:            SpriteCacheManager::getInstance()->loadMonsterDesertSpriteFile();            break;                    case LevelMusicEffectJungle:            SpriteCacheManager::getInstance()->loadMonsterJungleSpriteFile();            break;                    case LevelMusicEffectUnderground:            SpriteCacheManager::getInstance()->loadMonsterUndergroundSpriteFile();            break;    }}void BaseMap::releaseLevelMonsterSpriteCacheFile() {    switch (_musicEffect) {        case LevelMusicEffectDesert:            SpriteCacheManager::getInstance()->releaseMonsterDesertSpriteFile();            break;                    case LevelMusicEffectJungle:            SpriteCacheManager::getInstance()->releaseMonsterJungleSpriteFile();            break;                    case LevelMusicEffectUnderground:            SpriteCacheManager::getInstance()->releaseMonsterUndergroundSpriteFile();            break;    }}void BaseMap::playLevelMusicEffect() {    switch (_musicEffect) {        case LevelMusicEffectDesert:            SoundManager::playDesertBattle();            break;                    case LevelMusicEffectJungle:            SoundManager::playJungleBattle();            break;                    default:            break;    }}void BaseMap::waveEvent() {    this->playWaveAnimation(_currentWaveNumber);    this->schedule(schedule_selector(BaseMap::addMonsters), 1.0f, _waveVector.at(_currentWaveNumber).size(), 0);}bool BaseMap::playWaveAnimation(int currentWaveNumber) {    if (_waveAnimationMap.at(currentWaveNumber)) {        _waveAnimationMap.at(currentWaveNumber)->playAnimation();        return true;    } else {        return false;    }}void BaseMap::addMonsters(float dt) {    //waveVector.size（）为波束    //waveVector.at()保存该wave怪物，size为怪物个数    //waveVector.at().at()保存该0.5s内需要创建的怪物,.size为怪物个数    if( _time < _waveVector.at(_currentWaveNumber).size()) {        for(int i = 0 ; i < _waveVector.at(_currentWaveNumber).at(_time).size(); i++) {            auto monsterData = _waveVector.at(_currentWaveNumber).at(_time).at(i);            BaseMonster * monster = nullptr;                        /*             这里判断怪物是否需要新建，如果在已经死亡的怪物中找到同样类型的怪物，则使用这个已经死亡的怪物。             */            bool isNewMonster = false;            if (monsterData->getType() >= 0) {                monster = GameManager::getInstance()->getInusedMonster(monsterData->getType());                if (! monster) {                    isNewMonster = true;                    switch (monsterData->getType()) {                        case(MOSTER_TYPE_BOSS_EFREETI):                            monster = Boss_Efreeti::createMonster(_gamePaths.at(monsterData->getRoad()).at(monsterData->getPath()), _gamePaths);                            break;                        case(MOSTER_TYPE_BOSS_CANIBAL):                            monster = Boss_Canibal::createMonster(_gamePaths.at(monsterData->getRoad()).at(monsterData->getPath()), _gamePaths);                            break;                        default:                            monster = Monster::createMonster(monsterData->getType(), _gamePaths.at(monsterData->getRoad()).at(monsterData->getPath()));                            break;                    }                } else {                    monster->resetWithPaths(_gamePaths.at(monsterData->getRoad()).at(monsterData->getPath()));                }                            } else {                log("miss monster type : %d", monsterData->getType());            }            if (monster) {                this->addChild(monster);                GameManager::getInstance()->monsterVector.pushBack(monster);                if (!isNewMonster) {                    GameManager::getInstance()->monsterInusedVector.eraseObject(monster);                }            }        }        _time ++;    } else {        _time = 0;        if (_currentWaveNumber != _maxWaveNumber - 1) {            //15秒后显示WaveProgressBars            SoundManager::playNextWaveReady();            this->scheduleOnce(schedule_selector(BaseMap::showWaveProgressBars), 15.0f);        } else {            _isEnd = true;        }    }}#pragma mark - for Sprite frame File functionvoid BaseMap::loadLevelSpriteFrameFile() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_spriteframefiles.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        //parse the arraySpriteFrameFiles data    auto arraySpriteFrameFiles = valueMap.at("spriteframefiles").asValueVector();    for (int i = 0; i < arraySpriteFrameFiles.size(); i++) {        auto valueMap = (arraySpriteFrameFiles[i]).asValueMap();        std::string fileName  = "images/";        fileName.append((valueMap["file"]).asString().c_str());              SpriteFrameCache::getInstance()->addSpriteFramesWithFile(fileName);    }}void BaseMap::removeLevelSpriteFrameFile() {    std::string fileName = "xml/level" + std::to_string(getLevel()) + "_spriteframefiles.plist";    auto valueMap = FileUtils::getInstance()->getValueMapFromFile(fileName);        //parse the arraySpriteFrameFiles data    auto arraySpriteFrameFiles = valueMap.at("spriteframefiles").asValueVector();    for (int i = 0; i < arraySpriteFrameFiles.size(); i++) {        auto valueMap = (arraySpriteFrameFiles[i]).asValueMap();        std::string fileName  = "images/";        fileName.append((valueMap["file"]).asString().c_str());                SpriteFrameCache::getInstance()->removeSpriteFramesFromFile(fileName);    }        //这里主要是由于上述意见删除list，但是并没有从内存中将渲染图片文件删除，这里是删除语句    Director::getInstance()->getTextureCache()->removeUnusedTextures();}void BaseMap::loadMonsterAnimationCache() {    std::set<int>::iterator it;    for (it = _monsterTypeSet.begin(); it != _monsterTypeSet.end(); it++) {        log("Level: %d Monster Type : %d", _level, *it);        AnimationManager::getInstance()->initMonsterAnimationCache(*it);    }}void BaseMap::releaseMonsterAnimationCache() {    std::set<int>::iterator it;    for (it = _monsterTypeSet.begin(); it != _monsterTypeSet.end(); it++) {        AnimationManager::getInstance()->releaseMonsterAnimationCache(*it);//        _monsterTypeSet.at(i);    }}