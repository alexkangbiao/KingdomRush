#include "BaseTower.h"#include "Terrain.h"#include "TowerPanelLayer.h"#include "BaseMap.h"#include "GameManager.h"#include "TowerParameter.h"#include "TowerManager.hpp"#include "Utility.h"#include "SimplePanleLayer.h"BaseTower::BaseTower():_nearestMonster(nullptr),_isUpdateMenuShown(false){}BaseTower::~BaseTower(){}bool BaseTower::init() {	if (!Sprite::init()) {		return false;	}	_isUpdateMenuShown = false;	    return true;}#pragma mark - for terrain functionvoid BaseTower::addTerrainSprite(std::string terrainImageName) {    _terrainSprite = Sprite::createWithSpriteFrameName(terrainImageName);    _terrainSprite->setAnchorPoint(Point(0.5, 1));    this->addChild(_terrainSprite, BaseTowerDrawingOrderTerrain);    auto terrainListener = EventListenerTouchOneByOne::create();    terrainListener->onTouchBegan = CC_CALLBACK_2(BaseTower::onTerrainTouchBegan, this);    terrainListener->onTouchEnded = CC_CALLBACK_2(BaseTower::onTerrainTouchEnded, this);    _eventDispatcher->addEventListenerWithSceneGraphPriority(terrainListener, _terrainSprite);}bool BaseTower::onTerrainTouchBegan(Touch *touch, Event *event) {    return true;}void BaseTower::onTerrainTouchEnded(Touch* touch, Event* event) {    auto target = static_cast<Sprite*>(event->getCurrentTarget());    Point locationInNode = target->convertTouchToNodeSpace(touch);    Size size = target->getContentSize();    Rect rect = Rect(0, 0, size.width, size.height);        if (rect.containsPoint(locationInNode)) {        this->showTowerInfo();        if (_isUpdateMenuShown) {            this->hideUpdateMenu();        } else {            this->showUpdateMenu();        }    } else {        this->hideUpdateMenu();    }}#pragma mark - for tower  functionvoid BaseTower::setTowerType(int towerType) {    this->_towerType    = towerType;    auto towerParameter = TowerManager::getInstance()->getParameterByType(towerType);    this->_towerName   = towerParameter->getName();    this->_level       = towerParameter->getLevel();    this->_attackScope = towerParameter->getScope();    this->_nextScope   = towerParameter->getNextScope();//    this->_force       = towerParameter->getForce();    this->_buildMoney  = towerParameter->getBuildMoney();    this->_updateMoney = towerParameter->getUpdateMoney();    this->_shootPeriod = towerParameter->getPeriod();    this->_portraitsImageName = towerParameter->getPortraitsImageName();        this->_update1StartLevel = towerParameter->getUpdate1StartLevel();    this->_update2StartLevel = towerParameter->getUpdate2StartLevel();        this->prepareAnimation();        this->addAdditionalParameterConfig();}int BaseTower::getTowerType() {    return this->_towerType;}Point BaseTower::getTowerPosition() {    return this->getParent()->getPosition();}void BaseTower::showTowerInfo() {    static_cast<BaseMap*>(this->getParent()->getParent())->playerStateMenu->showTowerInfo(this);}void BaseTower::removeTowerInfo() {    static_cast<BaseMap*>(this->getParent()->getParent())->playerStateMenu->hideTowerInfo();;}void BaseTower::sellTower() {	static_cast<Terrain*>(this->getParent())->setTerrainBaseSpriteVisible(true);	this->removeTower();}void BaseTower::removeTower() {    //取得Tower的父指针，执行灰飞烟灭的效果    static_cast<Terrain*>(this->getParent())->executeSmokeEffect();        this->removeTowerInfo();	this->unscheduleAllCallbacks();	this->removeAllChildren();	this->removeFromParent();}#pragma mark - for common function/* 这里可以优化一下算法： 原来的算法是遍历所有的怪物，取得最近的怪物。  修改后的算法是： 1. 现判断事情的怪物是否为空，为空则搜索。不为空判断怪物和塔台的距离是否在射程之内，之内就还返回这个怪物。 2. 搜索怪物的算法修改为，进行符合条件的怪物遍历，返回第一个符合怪物和塔台的距离在射程之内的怪物  这样的话应该可以增加效率 */BaseMonster* BaseTower::getCanAttackMonster() {    if (_nearestMonster && _nearestMonster->getMonsterState() != MonsterStateDeath) {        if (this->getTowerPosition().getDistance(_nearestMonster->getMonsterPosition()) <= this->getAttackScope()) {            return _nearestMonster;        }    } else {        auto monsterVector = GameManager::getInstance()->monsterVector;        for(int i = 0; i < monsterVector.size(); i++) {            auto monster = monsterVector.at(i);            if (monster->getEnableAttackByTower()) {                /*                 这里优化一下算法，如果Tower和monster的x,y只差大于Tower的攻击范围，                 就不要检测距离了，这样应该可以减少计算量                 */                                if (Utility::estimationNearestDistance(this->getTowerPosition().x - monster->getMonsterPosition().x,                                                this->getTowerPosition().y - monster->getMonsterPosition().y,                                                this->getAttackScope())) {                    _nearestMonster = monster;                    return monster;                }            }        }    }    _nearestMonster = nullptr;    return nullptr;}//void BaseTower::checkNearestMonster()//{//    auto monsterVector = GameManager::getInstance()->monsterVector;//    //	auto currentMinDistant = this->getAttackScope();//    _monstersCount = 0;//    //	BaseMonster *monsterTemp = nullptr;//	for(int i = 0; i < monsterVector.size(); i++) {//		auto monster = monsterVector.at(i);//        if (monster->getEnableAttackByTower()) {//            //            if (Utility::estimationNearestDistance(this->getTowerPosition().x - monster->getMonsterPosition().x,//                                            this->getTowerPosition().y - monster->getMonsterPosition().y,//                                            currentMinDistant)) {//                double distance = this->getTowerPosition().getDistance(monster->getMonsterPosition());//                currentMinDistant = distance;//                monsterTemp = monster;//                _monstersCount++;//            }//        }//	}//    //    _nearestMonster = monsterTemp;//}void BaseTower::showUpdateMenu(){    auto simplePanleLayer = SimplePanleLayer::create();    simplePanleLayer->setTag(_terrain->getTag() + UPDATE_MENU_TAG);    simplePanleLayer->setTower(this);    simplePanleLayer->setPosition(this->getParent()->getPosition());    static_cast<BaseMap*>(this->getParent()->getParent())->mTouchLayer->addChild(simplePanleLayer);    simplePanleLayer->playShowAnimation();    _isUpdateMenuShown = true;}void BaseTower::hideUpdateMenu(){	static_cast<BaseMap*>(this->getParent()->getParent())->mTouchLayer->removeChildByTag(getTag() + UPDATE_MENU_TAG);	_isUpdateMenuShown = false;}#pragma mark - for animation functionvoid BaseTower::playBuildingAnimation() {    auto buildingAnimationSprite = Sprite::create();    auto constructingImage = Sprite::createWithSpriteFrameName("tower_constructing_0004.png");        auto hpBackgroundSprite = Sprite::createWithSpriteFrameName("buildbar_bg.png");    hpBackgroundSprite->setPosition(Point(constructingImage->getContentSize().width / 2,                                          constructingImage->getContentSize().height /2 + 10));    auto hpProgressBar = ProgressTimer::create(Sprite::createWithSpriteFrameName("buildbar.png"));    hpProgressBar->setType(ProgressTimer::Type::BAR);    hpProgressBar->setMidpoint(Point(0, 0.5f));    hpProgressBar->setBarChangeRate(Point(1, 0));    hpProgressBar->setPercentage(0);    hpProgressBar->setPosition(Point(hpBackgroundSprite->getContentSize().width / 2,                                     hpBackgroundSprite->getContentSize().height / 2 ));    hpBackgroundSprite->addChild(hpProgressBar);    constructingImage->addChild(hpBackgroundSprite);        buildingAnimationSprite->addChild(constructingImage);    this->addChild(buildingAnimationSprite, BaseTowerDrawingOrderTowerBase);        hpProgressBar->runAction(Sequence::create(ProgressTo::create(0.5f, 100),                                              CallFuncN::create(CC_CALLBACK_0(Sprite::removeFromParent, buildingAnimationSprite)),                                              NULL));    this->playSmokeEfftectAnimation();    this->scheduleOnce(schedule_selector(BaseTower::initTownForReady), 0.5f);}void BaseTower::playSmokeEfftectAnimation() {    auto smokeEfftect = Sprite::createWithSpriteFrameName("effect_buildSmoke_0001.png");    this->addChild(smokeEfftect, BaseTowerDrawingOrderEffect);    smokeEfftect->runAction(Sequence::create(                                             Animate::create(AnimationCache::getInstance()->getAnimation("build_smoke")),                                             CallFuncN::create(CC_CALLBACK_0(Sprite::removeFromParent, smokeEfftect)),                                             NULL));}float BaseTower::caculateSpendTime(Point toPoint, float bulletSpeed){    return toPoint.getDistance(this->getTowerPosition()) / bulletSpeed;}