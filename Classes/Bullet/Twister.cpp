#include "Twister.h"#include "GameManager.h"#include "Utility.h"bool Twister::init(){	if (!Bullet::initWithTypeAndLevel(BULLET_TYPE_TWISTER, 1)) {		return false;	}    //    this->setBulletType(BULLET_TYPE_TWISTER);//    this->setBulletScope(500);//    this->addBulletSprite("ArchMageTwister_0001.png");	_nearestMonster = nullptr;        this->scheduleOnce(schedule_selector(Twister::removeTwisterAction), 5.0f);    	return true;}void Twister::round(){	_bulletSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("ArchMageTwister_create")),                                              CallFuncN::create(CC_CALLBACK_0(Twister::attackMonster, this)),                                              NULL));}void Twister::attackMonster(){	SoundManager::playArchmageTwister();    	_bulletSprite->stopAllActions();	_bulletSprite->runAction(RepeatForever::create(Animate::create(AnimationCache::getInstance()->getAnimation("ArchMageTwister_twist"))));	this->schedule(schedule_selector(Twister::hitMonster), 0.5f);	this->schedule(schedule_selector(Twister::move), 1.0f);}void Twister::removeTwisterAction(float dt){   	this->unscheduleAllCallbacks();	_bulletSprite->stopAllActions();	_bulletSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("ArchMageTwister_end")),                                              CallFuncN::create(CC_CALLBACK_0(Twister::removeTwister, this)),                                              NULL));}void Twister::checkNearestMonster(){    auto monsterVector = GameManager::getInstance()->monsterVector;    	auto currentMinDistant = 500;    	BaseMonster *monsterTemp = NULL;	for(int i = 0; i < monsterVector.size(); i++)	{		auto monster = monsterVector.at(i);                if (Utility::estimationNearestDistance(this->getParent()->getPosition().x - monster->getMonsterPosition().x,                                               this->getParent()->getPosition().y - monster->getMonsterPosition().y,                                               currentMinDistant)) {            double distance = this->getParent()->getPosition().getDistance(monster->getMonsterPosition());            currentMinDistant = distance;            monsterTemp = monster;        }	}    _nearestMonster = monsterTemp;}void Twister::move(float dt){	this->checkNearestMonster();	if (_nearestMonster != NULL        && _nearestMonster->getCurrentHP() > 10        && _nearestMonster->getEnableAttackByTower()){                float duringTime = this->caculateSpendTime(_nearestMonster->getMonsterPosition());			this->runAction(MoveBy::create(duringTime,                    _nearestMonster->getMonsterPosition() - this->getBulletPosition()));	}}void Twister::removeTwister(){	this->removeFromParent();}void Twister::hitMonster(float dt){	GameManager *instance = GameManager::getInstance();	auto bulletRect = this->getBulletRect();	auto monsterVector = instance->monsterVector;    	for (int j = 0; j < monsterVector.size(); j++)	{		auto monster = monsterVector.at(j);		auto monsterRect = monster->getMonsterBoundingBox();					if (monsterRect.intersectsRect(bulletRect)  && monster->getEnableAttackByTower()) {            this->handleHP(monster);		}	}}