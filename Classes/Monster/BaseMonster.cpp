#include "BaseMonster.h"#include "GameManager.h"#include "BaseMap.h"#include "MonsterParameter.h"#include "MonsterManager.hpp"#include "GameManager.h"USING_NS_CC;BaseMonster::BaseMonster():_baseSprite(nullptr),_pointCounter(0),_runSpeed(0),_maxHp(0),_currentHP(0),_armor(0),_hpPercentage(100),_hpBar(NULL),_lastState(MonsterStateNone),_tempState(MonsterStateNone),_enableAttackBySoldier(true),_enableAttackByTower(true),_isAttacking(false),_isSlowed(false),_money(0){}BaseMonster::~BaseMonster() {}bool BaseMonster::initWithMonsterType(int monsterType) {    if (!Sprite::init()) {        return false;    }    this->setMonsterType(monsterType);        _lastState = MonsterStateNone;    this->setMonsterState(MonsterStateNone);        this->addBaseSprite();    this->addHPBackgroundAndBar();    this->addBloodSprite(_bloodColor);        this->scheduleUpdate();        return true;}#pragma mark - for init functionvoid BaseMonster::setMonsterType(int monsterType) {    this->_monsterType = monsterType;    auto monsterParameter = MonsterManager::getInstance()->getParameterByType(monsterType);    this->setMonsterName(monsterParameter->getName());    this->setMaxHp(monsterParameter->getMaxHP());    this->setCurrentHP(monsterParameter->getMaxHP());    this->setForce(monsterParameter->getForce());    this->setArmor(monsterParameter->getArmor());    this->setMoney(monsterParameter->getMoney());    this->setRunSpeed(monsterParameter->getSpeed());        _baseSpriteImageName = monsterParameter->getBaseImageName();    _bloodColor = monsterParameter->getBloodColor();        this->setEnableAttackBySoldier(monsterParameter->getCanAttackBySolier());    this->setEnableAttackByTower(monsterParameter->getCanAttackByTower());        this->setHaveChildren(monsterParameter->getHaveChildren());    this->setChildrenType(monsterParameter->getChildrenType());    this->setIsFly(monsterParameter->getIsFly());    this->setPortraitsImageName(monsterParameter->getPortraitsImageName());    this->setPortraitsName(monsterParameter->getPortraitsName());    }int BaseMonster::getMonsterType() {    return this->_monsterType;}void BaseMonster::addBloodSprite(std::string bloodColor) {    if (bloodColor != "none") {        if (bloodColor == "red") {            _bloodSprite = Sprite::createWithSpriteFrameName("fx_blood_splat_red_0001.png");        } else if (bloodColor == "green") {            _bloodSprite = Sprite::createWithSpriteFrameName("fx_blood_splat_green_0001.png");        } else {            _bloodSprite = Sprite::createWithSpriteFrameName("fx_blood_splat_red_0001.png");        }                _bloodSprite->setPosition(Point(_baseSprite->getContentSize().width / 2,                                        _baseSprite->getContentSize().height / 2));        _bloodSprite->setVisible(false);                _baseSprite->addChild(_bloodSprite, BaseMonsterDrawingOrderBlood);    }        _decalBlood = Sprite::createWithSpriteFrameName("decal_blood_0001.png");    _decalBlood->setPosition(Point(_baseSprite->getContentSize().width / 2,                                   - _baseSprite->getContentSize().height / 4));    _decalBlood->setVisible(false);    _baseSprite->addChild(_decalBlood, BaseMonsterDrawingOrderBlood);}void BaseMonster::addBaseSprite() {    _baseSprite = Sprite::createWithSpriteFrameName(_baseSpriteImageName);    this->addChild(_baseSprite, BaseMonsterDrawingOrderBackground);    auto listener = EventListenerTouchOneByOne::create();    listener->onTouchBegan = CC_CALLBACK_2(BaseMonster::onTouchBegan, this);    listener->onTouchEnded = CC_CALLBACK_2(BaseMonster::onTouchEnded, this);    _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, _baseSprite);}void BaseMonster::addHPBackgroundAndBar(){    _hpBackgroundSprite = Sprite::createWithSpriteFrameName("lifebar_bg_small.png");        _hpBackgroundSprite->setPosition(Point(_baseSprite->getContentSize().width / 2,                                          _baseSprite->getContentSize().height ));        _hpBar = ProgressTimer::create(Sprite::createWithSpriteFrameName("lifebar_small.png"));    _hpBar->setType(ProgressTimer::Type::BAR);    _hpBar->setMidpoint(Point(0, 0.5f));    _hpBar->setBarChangeRate(Point(1, 0));    _hpBar->setPercentage(_hpPercentage);    _hpBar->setPosition(Point(_hpBackgroundSprite->getContentSize().width / 2,                              _hpBackgroundSprite->getContentSize().height / 2 ));    _hpBackgroundSprite->addChild(_hpBar);    _baseSprite->addChild(_hpBackgroundSprite, BaseMonsterDrawingOrderHPBar);}#pragma mark - for common function//重新使用怪物的时候，将怪物复原到初始状态void BaseMonster::resetWithPaths(std::vector<Point> points) {    this->setPointsVector(points);    this->_pointCounter = 0;    this->setCurrentHP(this->getMaxHp());    _hpBar->setPercentage(100);    _hpBackgroundSprite->setVisible(true);        _lastState = MonsterStateNone;    _tempState = MonsterStateNone;    this->setMonsterState(MonsterStateNone);        _decalBlood->setVisible(false);    _bloodSprite->setVisible(false);        this->scheduleUpdate();    this->runToNextPoint();}Rect BaseMonster::getMonsterBoundingBox() {    return this->_baseSprite->getBoundingBox();}Point BaseMonster::getMonsterPosition() {    return this->_baseSprite->getPosition();}Point BaseMonster::getCurrentPoint() {    return _pointsVector.at(_pointCounter);}Point BaseMonster::getNextPoint() {    auto tempCounter = _pointCounter + 5;    if (tempCounter < _pointsVector.size()) {        auto point = this->_pointsVector.at(tempCounter);        return point;    }        return getCurrentPoint();}Point BaseMonster::getAndMoveToNextPoint() {    _pointCounter++;    if (_pointCounter < _pointsVector.size()  ){        auto point = this->_pointsVector.at(_pointCounter);        return point;    } else {        _pointCounter = _pointsVector.size() - 1 ;    }    return getCurrentPoint();}void BaseMonster::setMonsterZOrder(int yOrder) {    this->setLocalZOrder(10 - yOrder/100);}void BaseMonster::runToNextPoint(){    auto tempCurrentPoint = getCurrentPoint();        _baseSprite->setPosition(tempCurrentPoint);        _tempNextPoint = this->getAndMoveToNextPoint();    this->setMonsterZOrder(_tempNextPoint.y);        if (fabs(_tempNextPoint.y - tempCurrentPoint.y) > 5 && _tempNextPoint.y > tempCurrentPoint.y ) {        //正在向上走        this->setMonsterState(MonsterStateWalkUp);    } else if (fabs(_tempNextPoint.y - tempCurrentPoint.y) > 5 && _tempNextPoint.y <= tempCurrentPoint.y) {        //正在向下走        this->setMonsterState(MonsterStateWalkDown);    } else if (_tempNextPoint.x >= tempCurrentPoint.x) {        //正在向右走        this->setMonsterState(MonsterStateWalkRight);    } else if (_tempNextPoint.x < tempCurrentPoint.x) {        //正在向左走        this->setMonsterState(MonsterStateWalkLeft);    }        if ( _tempNextPoint != tempCurrentPoint ) {        auto duration =  tempCurrentPoint.getDistance(_tempNextPoint) / getRunSpeed() ;        _baseSprite->runAction(Sequence::create(MoveTo::create(duration, _tempNextPoint),                                                CallFuncN::create(CC_CALLBACK_0(BaseMonster::runToNextPoint, this)),                                                NULL));//        log("getMonsterPosition position: x:%f y:%f", this->getMonsterPosition().x, this->getMonsterPosition().y);//        log("getPosition position: x:%f y:%f", this->getPosition().x, this->getPosition().y);    } else {        //走到终点        GameManager::getInstance()->CURRENT_LIFE --;        GameManager::getInstance()->monsterVector.eraseObject(this);                GameManager::getInstance()->monsterInusedVector.pushBack(this);//        log("inused monster number: %ld", GameManager::getInstance()->monsterInusedVector.size());                        this->setCurrentHP(0);        this->setMonsterState(MonsterStateDeath);        _hpBackgroundSprite->setVisible(false);        _baseSprite->stopAllActions();        this->unscheduleAllCallbacks();        this->removeFromParent();    }    }void BaseMonster::update(float dt){    //若状态更新    if (_lastState != this->getMonsterState()) {        _baseSprite->stopActionByTag(_lastState);        _lastState = this->getMonsterState();                std::string actionAnimateName;        //根据状态判断        switch (this->getMonsterState()) {            case (MonsterStateWalkRight) : {                _baseSprite->setFlippedX(false);                actionAnimateName = this->getMonsterName() + "runright";            }                break;            case (MonsterStateWalkLeft): {                _baseSprite->setFlippedX(true);                actionAnimateName = this->getMonsterName() + "runleft";            }                break;            case (MonsterStateWalkUp): {                _baseSprite->setFlippedX(false);                actionAnimateName = this->getMonsterName() + "runup";            }                break;            case (MonsterStateWalkDown): {                _baseSprite->setFlippedX(false);                actionAnimateName = this->getMonsterName() + "rundown";            }                break;            case (MonsterStateAttackRight): {                _baseSprite->setFlippedX(false);                actionAnimateName = this->getMonsterName() + "attack";            }                break;            case (MonsterStateAttackLeft): {                _baseSprite->setFlippedX(true);                actionAnimateName = this->getMonsterName() + "attack";            }                break;                            default:                break;        }          if (!actionAnimateName.empty()            && AnimationCache::getInstance()->getAnimation(actionAnimateName)) {                        auto actionAnimate = Animate::create(AnimationCache::getInstance()->getAnimation(actionAnimateName));            auto action = RepeatForever::create(actionAnimate);            action->setTag(this->getMonsterState());            _baseSprite->runAction(action);        } else {            log("monster animation : %s not find", actionAnimateName.c_str());        }     }}#pragma mark - for virtual functionvoid BaseMonster::hurt() {    _bloodSprite->setVisible(true);    _bloodSprite->runAction(Sequence::create(Animate::create(AnimationCache::getInstance()->getAnimation("blood_red")),                                             CallFuncN::create(CC_CALLBACK_0(Sprite::setVisible, _bloodSprite, false)),                                             NULL));}void BaseMonster::death(){    Vector<FiniteTimeAction *> actionVector;    if (AnimationCache::getInstance()->getAnimation(this->getMonsterName() + "death") != nullptr) {        actionVector.pushBack(Animate::create(AnimationCache::getInstance()->getAnimation(this->getMonsterName() + "death")));    }    actionVector.pushBack(CallFuncN::create(CC_CALLBACK_0(Sprite::setVisible, this, false)));    this->playCommonDeath(Sequence::create(actionVector));}void BaseMonster::explosion(){    Vector<FiniteTimeAction *> actionVector;    if (AnimationCache::getInstance()->getAnimation("explosion_Artillery") != nullptr) {        actionVector.pushBack(Animate::create(AnimationCache::getInstance()->getAnimation("explosion_Artillery")));    }    this->playCommonDeath(Sequence::create(actionVector));}void BaseMonster::playCommonDeath(Sequence* sequence) {    if (GameManager::getInstance()->monsterVector.contains(this))        GameManager::getInstance()->monsterVector.eraseObject(this);        if (this->getMonsterState() != MonsterStateDeath) {        this->setCurrentHP(0);        this->setMonsterState(MonsterStateDeath);        _hpBackgroundSprite->setVisible(false);        _baseSprite->stopAllActions();        this->unscheduleUpdate();                //流血        _decalBlood->setVisible(true);        _decalBlood->runAction(Sequence::create(FadeOut::create(1.0f),                                                CallFuncN::create(CC_CALLBACK_0(Sprite::setVisible, this, false)),                                                FadeIn::create(0.0f),                                                nullptr));        //添加金钱        this->addMoneyLabel();        GameManager::getInstance()->CURRENT_MONEY +=  this->getMoney();                _baseSprite->runAction(sequence);                        //如果这个怪物有子怪物的话，就会执行下面的程序，生成子怪物        this->birthChildrenMonster();                //将自己删除        this->handleDeathMonster();    }}void BaseMonster::addMoneyLabel() {    static_cast<BaseMap*>(this->getParent())->mTouchLayer->addMoneyLabel(this->getMonsterPosition(), this->getMoney());}void BaseMonster::handleDeathMonster() {    GameManager::getInstance()->monsterInusedVector.pushBack(this);//    log("inused monster number: %ld", GameManager::getInstance()->monsterInusedVector.size());    this->removeFromParent();}void BaseMonster::frozen(){    if (getMonsterState() != MonsterStateFrozen) {        _tempState = _lastState;        this->setMonsterState(MonsterStateFrozen);        _baseSprite->stopAllActions();        if (this->getIsFly()) {            _ice = Sprite::createWithSpriteFrameName("freeze_creepFlying_0009.png");        } else {            _ice = Sprite::createWithSpriteFrameName("freeze_creep_0007.png");        }                _ice->setPosition(Point(_baseSprite->getContentSize().width / 2,                                _baseSprite->getContentSize().height / 4));        _baseSprite->addChild(_ice);                if (this->getIsFly()) {            _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creepFlying")));        } else {            _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creep")));        }                this->scheduleOnce(schedule_selector(BaseMonster::refrozen), GameManager::getInstance()->MONSTER_FROZEN_TIME);    } else {        this->unschedule(schedule_selector(BaseMonster::refrozen));        this->scheduleOnce(schedule_selector(BaseMonster::refrozen), GameManager::getInstance()->MONSTER_FROZEN_TIME);        _ice->stopAllActions();        _ice->removeFromParent();                if (this->getIsFly()) {            _ice = Sprite::createWithSpriteFrameName("freeze_creepFlying_0009.png");        } else {            _ice = Sprite::createWithSpriteFrameName("freeze_creep_0007.png");        }                _ice->setPosition(Point(_baseSprite->getContentSize().width / 2,                                _baseSprite->getContentSize().height / 4));        _baseSprite->addChild(_ice);                if (this->getIsFly()) {            _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creepFlying")));        } else {            _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creep")));        }    }}void BaseMonster::refrozen(float dt){    if (this->getIsFly()) {        _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creepFlying")));    } else {        _ice->runAction(Animate::create(AnimationCache::getInstance()->getAnimation("freeze_creep")));    }        _ice->runAction(Sequence::create(CallFuncN::create(CC_CALLBACK_0(Sprite::removeFromParent, _ice)),                                    CallFuncN::create(CC_CALLBACK_0(BaseMonster::restartWalking, this)),                                    NULL));}void BaseMonster::stopWalking(){    _tempState = _lastState;    _baseSprite->stopAllActions();}void BaseMonster::restartWalking(){    _lastState = MonsterStateNone;    _baseSprite->stopAllActions();    this->setMonsterState(_tempState);        auto tempCurrentPoint = _baseSprite->getPosition();    auto duration =  tempCurrentPoint.getDistance(_tempNextPoint) / getRunSpeed();    _baseSprite->runAction(Sequence::create(MoveTo::create(duration, _tempNextPoint),                                            CallFuncN::create(CC_CALLBACK_0(BaseMonster::runToNextPoint, this)),                                            NULL));}void BaseMonster::runOnSlowSpeed(float dt, float dis){    if(!_isSlowed){        _isSlowed = true;        auto temp = this->getRunSpeed();        this->setRunSpeed(temp - dis);        this->runAction(Sequence::create(                                   DelayTime::create(dt),                                   CallFuncN::create(CC_CALLBACK_0(BaseMonster::setRunSpeed, this, temp)),                                   CallFuncN::create(CC_CALLBACK_0(BaseMonster::setIsSlowed, this, false)),                                   NULL));    }}Size BaseMonster::getMonsterContentSize() {    return this->_baseSprite->getContentSize();}#pragma mark - for callback function/*    点击怪物显示怪物的信息  */bool BaseMonster::onTouchBegan(Touch* touch, Event* event){    auto target = static_cast<Sprite*>(event->getCurrentTarget());        Point locationInNode = target->convertTouchToNodeSpace(touch);        Size size = target->getContentSize();    Rect rect = Rect(0, 0, size.width, size.height);    if (rect.containsPoint(locationInNode) && this->isVisible()){        return true;    }    return false;}void BaseMonster::onTouchEnded(Touch* touch, Event* event){    static_cast<BaseMap*>(this->getParent())->playerStateMenu->showMonsterInfo(this);}