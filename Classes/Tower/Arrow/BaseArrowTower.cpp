#include "BaseArrowTower.h"#include "UpdatePanelLayer.h"#include "GameManager.h"#include "Utility.h"#include "Arrow.h"#include "TowerUpdateManager.h"bool BaseArrowTower::init() {    if (!BaseTower::init()) {        return false;    }    this->addTerrainSprite("terrain_archer_0004.png");    _shooterTag = ArrowShooterTag_1;    _currentBullet = nullptr;    return true;}void BaseArrowTower::initArrowTowerBase(int level) {    towerBase = Sprite::createWithSpriteFrameName(Utility::string_format("archer_tower_000%d.png", level));        shooter_1 = Sprite::createWithSpriteFrameName(Utility::string_format("tower_archer_lvl%d_shooter_0001.png", level));    shooter_2 = Sprite::createWithSpriteFrameName(Utility::string_format("tower_archer_lvl%d_shooter_0001.png", level));        shooter_1->setPosition(Point(towerBase->getContentSize().width  / 2 - shooter_1->getContentSize().width / 2,                                 towerBase->getContentSize().height / 2 + shooter_1->getContentSize().height / 2));    shooter_2->setPosition(Point(towerBase->getContentSize().width  / 2 + shooter_2->getContentSize().width / 2,                                 towerBase->getContentSize().height / 2 + shooter_2->getContentSize().height / 2));        towerBase->addChild(shooter_1);    towerBase->addChild(shooter_2);        this->addChild(towerBase, BaseTowerDrawingOrderTowerBase);}#pragma mark - for bullet functionBullet* BaseArrowTower::getArrowTowerBullet() {//    log("arrow vector number is : %ld", _bulletVector.size());        //循环使用已经生成的子弹，否则就转到生成新子弹    for (int i = 0; i < _bulletVector.size(); i++) {        if (!_bulletVector.at(i)->getParent()) {            _bulletVector.at(i)->restoreBullet();            this->getParent()->addChild(_bulletVector.at(i));            return _bulletVector.at(i);        }    }        //生成新子弹，然后将新子弹加入到队列中    auto bullet = Arrow::createArrowWithLevel(this->getLevel());    bullet->setRotation(90.0f);//    bullet->refreshTypeAndLevel(bullet->getBulletType(), this->getLevel());    this->getParent()->addChild(bullet);    _bulletVector.pushBack(bullet);        return bullet;}void BaseArrowTower::refreshBulletVector() {    _bulletVector.clear();}void BaseArrowTower::prepareAnimation() {    std::string animationNameDown = Utility::string_format("level%d_shoot_down", _level);    _shooterDownAnimation = AnimationCache::getInstance()->getAnimation(animationNameDown);    std::string animationNameUp = Utility::string_format("level%d_shoot_top", _level);    _shooterUpAnimation   = AnimationCache::getInstance()->getAnimation(animationNameUp);}void BaseArrowTower::shoot(float dt) {    //    this->checkNearestMonster();    _nearestMonster = this->getCanAttackMonster();        //判断最近的怪物是否在射程之内    if (_nearestMonster != nullptr        && _nearestMonster->getCurrentHP() > 0) {        _currentBullet = this->getArrowTowerBullet();                this->shootAdditionalWeapon();                Point shootVector = _nearestMonster->getMonsterPosition() - this->getTowerPosition();                //向左攻击        if (shootVector.x - _currentBullet->getPosition().x <= 0) {            if (_shooterTag == ArrowShooterTag_1) {                //轮到1号弓箭手                _currentBullet->setPosition(Point(0,                                                 towerBase->getContentSize().height / 2)); //子弹设置在弓箭手所在位置                shooter_1->setFlippedX(true);                if (shootVector.y - _currentBullet->getPosition().y <= 0) {                    //攻击动画                    shooter_1->runAction(Animate::create(_shooterDownAnimation));                } else {                    shooter_1->runAction(Animate::create(_shooterUpAnimation));                }                _shooterTag = ArrowShooterTag_2;            } else {                //轮到2号弓箭手                _currentBullet->setPosition(Point(shooter_2->getContentSize().width / 2,                                                 towerBase->getContentSize().height / 2));                shooter_2->setFlippedX(true);                if (shootVector.y - _currentBullet->getPosition().y <= 0) {                    shooter_2->runAction(Animate::create(_shooterDownAnimation));                } else {                    shooter_2->runAction(Animate::create(_shooterUpAnimation));                }                _shooterTag = ArrowShooterTag_1;            }            //向右攻击        } else {            if (_shooterTag == ArrowShooterTag_1) {                _currentBullet->setPosition(Point(0,                                                 towerBase->getContentSize().height / 2));                shooter_1->setFlippedX(false);                if (shootVector.y - _currentBullet->getPosition().y <= 0) {                    shooter_1->runAction(Animate::create(_shooterDownAnimation));                } else {                    shooter_1->runAction(Animate::create(_shooterUpAnimation));                }                _shooterTag = ArrowShooterTag_2;            } else {                _currentBullet->setPosition(Point(shooter_2->getContentSize().width / 2,                                                 towerBase->getContentSize().height / 2));                shooter_2->setFlippedX(false);                if (shootVector.y - _currentBullet->getPosition().y <= 0) {                    shooter_2->runAction(Animate::create(_shooterDownAnimation));                } else {                    shooter_2->runAction(Animate::create(_shooterUpAnimation));                }                _shooterTag = ArrowShooterTag_1;            }        }                this->playShootVoice();        //攻击属性给弓箭        _currentBullet->setBulletAction(this->getBulletAction());        _currentBullet->shoot();        _currentBullet = nullptr;    }}Spawn* BaseArrowTower::getBulletAction() {    Point shootVector = _nearestMonster->getMonsterPosition() - this->getTowerPosition();    float endAngle = 0; //结束角度    if (shootVector.x - _currentBullet->getPosition().x <= 0) {        endAngle = -90;    } else {        endAngle = 270;    }        //设置箭的起始角度    _currentBullet->setRotation(90);        /*     这里存在一个问题：     这里算的是运动轨迹，这里查找一个最近的怪物作为基准点，但是射击后怪物会移动，然后再箭头再遍历怪物，算出和箭头交叉的怪物进行杀害，     这样增加的系统负载。     */    ccBezierConfig bezier;    //两个控制点    bezier.controlPoint_1 = Point(_currentBullet->getPosition().x,                                  _currentBullet->getPosition().y + 50);    bezier.controlPoint_2 = Point(shootVector.x,                                  shootVector.y + 50);    bezier.endPosition = shootVector;        float duringTime = this->caculateSpendTime(_nearestMonster->getMonsterPosition(), _currentBullet->getBulletSpeed());        auto action = Spawn::create(BezierTo::create(duringTime, bezier),                                RotateTo::create(duringTime, endAngle),                                NULL);    return action;}void BaseArrowTower::playShootVoice() {    if (_shooterTag == ArrowShooterTag_1)        SoundManager::playArrowShoot1();    else        SoundManager::playArrowShoot2();}void BaseArrowTower::addAdditionalParameterConfig() {    this->setUpdateMoney(this->getUpdateMoney() * (1 + TowerUpdateManager::getInstance()->getTowerUpgradeValue(UpgradeTowerTagArrow02_ReduceBuildMoney)));    this->setAttackScope(this->getAttackScope() * (1 + TowerUpdateManager::getInstance()->getTowerUpgradeValue(UpgradeTowerTagArrow03_IncreaseScope)));    this->setShootPeriod(this->getShootPeriod() * (1 + TowerUpdateManager::getInstance()->getTowerUpgradeValue(UpgradeTowerTagArrow04_ShootPeriod)));}