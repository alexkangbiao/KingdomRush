#include "BaseSoldier.h"#include "GameManager.h"#include "SoldierParameter.h"#include "SoldierManager.hpp"#include "Utility.h"BaseSoldier::BaseSoldier() :baseSprite(NULL),_attackCount(0),_level(1),_maxHp(0.0),_currentHP(0.0),_force(0.0),_armor(0.0),_runSpeed(100.0),_hpPercentage(100.0),_location(Vec2::ZERO),_animationDeath(nullptr),_animationRun(nullptr),_animationBirth(nullptr),_animationAttack(nullptr),_animationSkill1(nullptr),_animationSkill2(nullptr){}bool BaseSoldier::initWithSoldierType(SoldierType soldierType, int level) {    if (!Sprite::init()) {        return false;    }        this->setSoldierParameter(soldierType, level);        _lastState = SoldierStateNone;    _nearestMonster = nullptr;    _farestMonster  = nullptr;        //设置所需要的动画和贴片    this->setAnimationAndOthers();        //设置主要的背景贴片图片    this->addBaseSprite();    //添加HP的bar显示    this->addHPBackgroundAndBar();        this->schedule(schedule_selector(BaseSoldier::cureSoldier), this->getCurePeriod(), 0, this->getCurePeriod());        return true;}void BaseSoldier::setSoldierParameter(SoldierType soldierType, int level) {    auto soldierParameter = SoldierManager::getInstance()->getParameterByType(soldierType, level);    this->setSoldierType(soldierType);    this->setLevel(level);    this->setSoldierName(soldierParameter->getName());    this->setMaxHp(soldierParameter->getMaxHP());    this->setCurrentHP(soldierParameter->getMaxHP());    this->setForce(soldierParameter->getForce());    this->setArmor(soldierParameter->getArmor());    this->setRunSpeed(soldierParameter->getSpeed());    this->setAttackScope(soldierParameter->getScope());    this->setAttackPeriod(soldierParameter->getAttackPeriod());    this->setCurePeriod(soldierParameter->getCurePeriod());    this->setCurePercentage(soldierParameter->getCurePercentage());        this->setState(SoldierStateNone);        this->addAdditionalParameterConfig();}#pragma mark - for add functionvoid BaseSoldier::addBaseSprite() {    baseSprite = Sprite::createWithSpriteFrame(_soldierWaitingSpriteFrame);    this->addChild(baseSprite, BaseSoldierDrawingOrderBackground);}void BaseSoldier::addHPBackgroundAndBar(){    _hpBackgroungSprite = Sprite::createWithSpriteFrameName("lifebar_bg_small.png");    _hpBackgroungSprite->setPosition(Point(baseSprite->getContentSize().width / 2,                                           baseSprite->getContentSize().height / 3 * 2));    baseSprite->addChild(_hpBackgroungSprite, BaseSoldierDrawingOrderHPBar);    	_hpBar = ProgressTimer::create(Sprite::createWithSpriteFrameName("lifebar_small.png"));	_hpBar->setType(ProgressTimer::Type::BAR);	_hpBar->setMidpoint(Point(0, 0.5f));	_hpBar->setBarChangeRate(Point(1, 0));	_hpBar->setPercentage(100);    _hpBar->setPosition(Point(_hpBackgroungSprite->getContentSize().width / 2,                              _hpBackgroungSprite->getContentSize().height / 2 ));    _hpBackgroungSprite->addChild(_hpBar);}#pragma mark - for add function/* 士兵攻击怪物的顺序是这样的： 1. runToLocation，跑向指定的地点，然后就schedule发现怪物的计划任务； 2. lookingForMonsters发现怪物的计划任务，通过检查最近的怪物，当发现合适的怪物的时候就会准备攻击。 3. readyForAttackMonster，准备攻击， 先讲2的计划任务结束，然后跑向怪物。 4. runToMonster，跑向怪物，到达怪物附件后就攻击怪物。 5. attackMonster，攻击怪物， 攻击完成后，如果还活着就重新1. */void BaseSoldier::readyForAttackMonster(){    this->unschedule(schedule_selector(BaseSoldier::lookingForMonsters));    this->runToMonster();}//跑向怪物void BaseSoldier::runToMonster(){	Point destination;    //检查怪物所在的方位，并翻转图片，使得图片朝向怪物方向	if (! this->checkDirectionForMonster()) {//怪在右边		destination.x =   _nearestMonster->getMonsterPosition().x                        + _nearestMonster->getMonsterContentSize().width / 2                        - this->getTowerPosition().x                        - this->getSoldierContentSize().width / 2;                		destination.y = _nearestMonster->getMonsterPosition().y                        - this->getTowerPosition().y                        - this->getSoldierContentSize().height / 4;	} else {//左边		destination.x = _nearestMonster->getMonsterPosition().x                        - _nearestMonster->getMonsterContentSize().width / 2                        - this->getTowerPosition().x                        + this->getSoldierContentSize().width / 2;        		destination.y = _nearestMonster->getMonsterPosition().y                        - this->getTowerPosition().y                        - this->getSoldierContentSize().height / 4;	}	this->setState(SoldierStateRun);	this->runAction(Sequence::create(MoveTo::create(this->caculateSpendTime(destination), destination) ,                                     NULL));	this->schedule(schedule_selector(BaseSoldier::attackMonster), this->getAttackPeriod(), -1, this->caculateSpendTime(destination));}void BaseSoldier::reviveSoldier() {    _lastState = SoldierStateNone;    this->setState(SoldierStateNone);        _nearestMonster = nullptr;    _farestMonster  = nullptr;        this->setCurrentHP(this->getMaxHp());    this->getHpBar()->setPercentage(100);    _hpBackgroungSprite->setVisible(true);    baseSprite->setSpriteFrame(_soldierWaitingSpriteFrame);    baseSprite->setVisible(true);    this->setVisible(true);        this->setPosition(Vec2::ZERO);    this->runToLocation(this->getTowerPosition() + BIRTH_LOCATION_POINT);    this->runToLocation(this->getLocation());//    this->runToLocation(this->getTowerPosition() + BIRTH_LOCATION_POINT);}void BaseSoldier::runToLocation(Point toPoint){	if (this->getState() != SoldierStateDeath) {		this->unscheduleAllCallbacks();		this->scheduleUpdate();		this->stopAllActions();        		if ((toPoint.x - this->getPositionX()) > 0) {			baseSprite->setFlippedX(false);//右边		} else {			baseSprite->setFlippedX(true);		}		this->setState(SoldierStateRun);		this->runAction(Sequence::create(MoveTo::create(this->caculateSpendTime(toPoint), toPoint),                                         CallFuncN::create(CC_CALLBACK_0(BaseSoldier::setState, this, SoldierStateWait)),                                         NULL));		this->schedule(schedule_selector(BaseSoldier::lookingForMonsters),                       this->getAttackPeriod(), -1, this->caculateSpendTime(toPoint));	}}void BaseSoldier::lookingForMonsters(float dt){	this->setState(SoldierStateWait);	baseSprite->setFlippedX(!(baseSprite->isFlippedX()));    	this->checkNearestMonster();        //如果发现有合适的怪物，就准备去袭击怪物	if (_nearestMonster != nullptr && _nearestMonster->getCurrentHP() > 0) {		this->readyForAttackMonster();	}}/* 这里可以优化一下算法： 原来的算法是遍历所有的怪物，取得最近的怪物。  修改后的算法是： 1. 现判断事情的怪物是否为空，为空则搜索。不为空判断怪物和塔台的距离是否在射程之内，之内就还返回这个怪物。 2. 搜索怪物的算法修改为，进行符合条件的怪物遍历，返回第一个符合怪物和塔台的距离在射程之内的怪物  这样的话应该可以增加效率 */BaseMonster* BaseSoldier::getCanAttackMonster() {    if (_nearestMonster && _nearestMonster->getMonsterState() != MonsterStateDeath) {        if (Utility::estimationNearestDistance(                                               this->getTowerPosition().x  + this->getPosition().x - _nearestMonster->getMonsterPosition().x,                                               this->getTowerPosition().y  + this->getPosition().y - _nearestMonster->getMonsterPosition().y,                                               this->getAttackScope())) {            return _nearestMonster;        }    } else {        auto monsterVector = GameManager::getInstance()->monsterVector;        for(int i = 0; i < monsterVector.size(); i++) {            auto monster = monsterVector.at(i);            if (monster->getEnableAttackBySoldier() && ! monster->getIsAttacking()) {                if (Utility::estimationNearestDistance(                                                       this->getTowerPosition().x  + this->getPosition().x - monster->getMonsterPosition().x,                                                       this->getTowerPosition().y  + this->getPosition().y - monster->getMonsterPosition().y,                                                       this->getAttackScope())) {                    _nearestMonster = monster;                    return monster;                }            }        }    }    _nearestMonster = nullptr;    return nullptr;}/* 检查最近的怪物 */void BaseSoldier::checkNearestMonster(){    auto monsterVector = GameManager::getInstance()->monsterVector;    _nearestMonster = nullptr;	for(int i = 0; i < monsterVector.size(); i++)	{		auto monster = monsterVector.at(i);        if (monster->getEnableAttackBySoldier() && ! monster->getIsAttacking()) {            /*             这里优化一下算法，如果Tower和monster的x,y只差大于Tower的攻击范围，             就不要检测距离了，这样应该可以减少计算量             */            if (Utility::estimationNearestDistance(                                            this->getTowerPosition().x  + this->getPosition().x - monster->getMonsterPosition().x,                                            this->getTowerPosition().y  + this->getPosition().y - monster->getMonsterPosition().y,                                            this->getAttackScope())) {                _nearestMonster = monster;                _nearestMonster->stopWalking();                _nearestMonster->setIsAttacking(true);                break;            }        }	}}/* 检查最远的怪物 */void BaseSoldier::checkFarestMonster() {    auto monsterVector = GameManager::getInstance()->monsterVector;        auto currentMinDistant = 200;        BaseMonster *monsterTemp = nullptr;    for(int i = 0; i < monsterVector.size(); i++)    {        auto monster = monsterVector.at(i);        if (monster->getEnableAttackBySoldier() && ! monster->getIsAttacking()) {            if (Utility::estimationFarestDistance(                                            this->getTowerPosition().x  + this->getPosition().x - monster->getMonsterPosition().x,                                            this->getTowerPosition().y  + this->getPosition().y - monster->getMonsterPosition().y,                                            this->getAttackScope())) {                double distance = this->getParent()->getPosition().getDistance(monster->getMonsterPosition());                currentMinDistant = distance;                monsterTemp = monster;                break;            }        }    }    _farestMonster = monsterTemp;}//检查怪物相对自己的方位，是在左边还是右边，然后翻转自己的身体朝向怪物bool BaseSoldier::checkDirectionForMonster(){	if ((_nearestMonster->getMonsterPosition().x            - (this->getParent()->getParent()->getPositionX()               + this->getPositionX())) > 0) {		baseSprite->setFlippedX(false);		return false;	} else {		baseSprite->setFlippedX(true);		return true;	}}#pragma mark - for some geter functionPoint BaseSoldier::getSoldierPosition() {    return this->baseSprite->getPosition();}Size BaseSoldier::getSoldierContentSize() {    return this->baseSprite->getContentSize();}Point BaseSoldier::getTowerPosition() {   return this->getParent()->getParent()->getPosition();}#pragma mark - for private functionvoid BaseSoldier::cureSoldier(float dt) {    if (this->getState() == SoldierStateWait && this->getCurePercentage() < 100.0f) {        float currentHP = this->getCurrentHP() + this->getMaxHp() * this->getCurePercentage();        float percentage = (currentHP / this->getMaxHp()) * 100;        if (percentage > 100) percentage = 100;                this->setCurrentHP(currentHP);        this->setHpPercentage(percentage);        this->getHpBar()->setPercentage(percentage);    }}void BaseSoldier::update(float dt){    //若状态更新    if (_lastState != this->getState()) {        baseSprite->stopActionByTag(_lastState);        _lastState = this->getState();                Action* actionForAnimation = nullptr;        switch (this->getState())        {            case (SoldierStateRun): {                if (_animationRun != nullptr) {                    actionForAnimation = RepeatForever::create(Animate::create(_animationRun));                }            }                break;            case (SoldierStateAttack): {                if (_animationAttack != nullptr) {                    actionForAnimation = RepeatForever::create(Animate::create(_animationAttack));                }            }                break;            case (SoldierStateWait):{                baseSprite->setSpriteFrame(_soldierWaitingSpriteFrame);            }                break;            case (SoldierStateSkill1): {//致命一击                if (_animationSkill1 != nullptr) {                    actionForAnimation = RepeatForever::create(Animate::create(_animationSkill1));                }            }                break;            case (SoldierStateSkill2): {//闪避                if (_animationSkill2 != nullptr) {                    actionForAnimation = RepeatForever::create(Animate::create(_animationSkill2));                }            }            default:                break;        }                if (actionForAnimation != nullptr) {            actionForAnimation->setTag(this->getState());            baseSprite->runAction(actionForAnimation);        }            }}void BaseSoldier::setSoldierAttackState(float & monsterCurrentHP) {    this->setState(SoldierStateAttack);    monsterCurrentHP =  monsterCurrentHP - this->getForce() + _nearestMonster->getArmor();}void BaseSoldier::attackMonster(float dt){    //检测最近的怪物是否存在，并存活    if (_nearestMonster != nullptr && _nearestMonster->getCurrentHP() > 0) {        if (! this->checkDirectionForMonster()) {            _nearestMonster->setMonsterState(MonsterStateAttackLeft);        } else {            _nearestMonster->setMonsterState(MonsterStateAttackRight);        }                auto monsterCurrentHP = _nearestMonster->getCurrentHP();        auto soldierCurrentHP = this->getCurrentHP();                this->setSoldierAttackState(monsterCurrentHP);        if (_nearestMonster->getMonsterState() != MonsterStateFrozen)            soldierCurrentHP =  soldierCurrentHP - _nearestMonster->getForce() + this->getArmor();                if (monsterCurrentHP <= 0)  monsterCurrentHP = 0;        _nearestMonster->setCurrentHP( monsterCurrentHP );        _nearestMonster->getHpBar()->setPercentage((monsterCurrentHP / _nearestMonster->getMaxHp()) * 100);                if (soldierCurrentHP <= 0) soldierCurrentHP = 0;        this->setCurrentHP(soldierCurrentHP);        this->getHpBar()->setPercentage((soldierCurrentHP / this->getMaxHp()) * 100);                if (monsterCurrentHP == 0) {            this->unschedule(schedule_selector(BaseSoldier::attackMonster));            _nearestMonster->death();            if (this->getCurrentHP() > 0) this->runToLocation(_location);        }                if (soldierCurrentHP == 0) {            _lastState = SoldierStateDeath;//            this->setState(SoldierStateDeath);            this->unscheduleAllCallbacks();            this->stopAllActions();            baseSprite->stopAllActions();            _hpBackgroungSprite->setVisible(false);                        if (_nearestMonster != nullptr && _nearestMonster->getCurrentHP() > 0) {                _nearestMonster->restartWalking();                _nearestMonster->setIsAttacking(false);            }                        Vector<FiniteTimeAction *> actionVector;            if (_animationDeath != nullptr) {                actionVector.pushBack(Animate::create(_animationDeath));            }            actionVector.pushBack(FadeOut::create(1.0f));//            actionVector.pushBack(CallFuncN::create(CC_CALLBACK_0(BaseSoldier::removeFromParent, this)));            actionVector.pushBack(CallFuncN::create(CC_CALLBACK_0(Sprite::setVisible, this, false)));            actionVector.pushBack(FadeIn::create(0.0f));            actionVector.pushBack(CallFuncN::create(CC_CALLBACK_0(BaseSoldier::setState, this, SoldierStateDeath)));                        baseSprite->runAction(Sequence::create(actionVector));        }    } else {        this->unschedule(schedule_selector(BaseSoldier::attackMonster));        if (this->getCurrentHP() > 0) runToLocation(_location);    }}float BaseSoldier::caculateSpendTime(Point toPoint){    return toPoint.getDistance(this->getPosition()) / this->getRunSpeed();}